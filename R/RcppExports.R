# This file was generated by Rcpp::compileAttributes
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' @title Generate Random Wishart Distribution
#' @description Creates a random wishart distribution when given degrees of freedom and a sigma matrix. 
#' @param df An \code{int}, which gives the degrees of freedom of the Wishart.  (> 0)
#' @param S A \code{matrix} with dimensions m x m that provides Sigma, the covariance matrix. 
#' @return A \code{matrix} that is a Wishart distribution, aka the sample covariance matrix of a Multivariate Normal Distribution
#' @seealso \code{\link{riwishart}} 
#' @author James J Balamuta
#' @examples 
#' #Call with the following data:
#' rwishart(3, diag(2))
#' 
#' # Validation
#' set.seed(1337)
#' S = toeplitz((10:1)/10)
#' n = 10000
#' o = array(dim = c(10,10,n))
#' for(i in 1:n){
#' o[,,i] = rwishart(20, S)
#' }
#' mR = apply(o, 1:2, mean)
#' Va = 20*(S^2 + tcrossprod(diag(S)))
#' vR = apply(o, 1:2, var)
#' stopifnot(all.equal(vR, Va, tolerance = 1/16))
#' 
rwishart <- function(df, S) {
    .Call('r2arma_rwishart', PACKAGE = 'r2arma', df, S)
}

#' @title Generate Random Inverse Wishart Distribution
#' @description Creates a random inverse wishart distribution when given degrees of freedom and a sigma matrix. 
#' @param df An \code{int} that represents the degrees of freedom.  (> 0)
#' @param S A \code{matrix} with dimensions m x m that provides Sigma, the covariance matrix. 
#' @return A \code{matrix} that is an inverse wishart distribution.
#' @seealso \code{\link{rwishart}}
#' @author James J Balamuta
#' @examples 
#' #Call with the following data:
#' riwishart(3, diag(2))
riwishart <- function(df, S) {
    .Call('r2arma_riwishart', PACKAGE = 'r2arma', df, S)
}

#' @title Reverse Subset Column
#' @description Subsets the column by going from high indices to low (the reverse of the supported practice)
#' @usage rev_col_subset(x, start, end)
#' @param x A \code{matrix} of dimensions M x N
#' @param start A \code{unsigned int} that indicates the starting column.
#' @param end A \code{unsigned int} that indicates the ending column.
#' @return x A \code{matrix} with matrix rows displayed in reverse order
#' @details Consider a vector x=[[1,2],[3,4]].
#' By setting \code{start=1} and \code{end=0}, the function would output x=[[2,1],[4,1]].
#' Start and end must be valid C++ matrix locations. (e.g. matrix cols start at 0 and not 1)
#' @author JJB
#' @examples
#' x = matrix(c(1,2,3,4), nrow = 2,byrow = TRUE)
#' rev_col_subset(x, 1, 0)
rev_col_subset <- function(x, start, end) {
    .Call('r2arma_rev_col_subset', PACKAGE = 'r2arma', x, start, end)
}

#' @title Reverse Subset Row
#' @description Subsets the row by going from high indices to low (the reverse of the supported practice)
#' @usage rev_row_subset(x, start, end)
#' @param x A \code{matrix} of dimensions M x N
#' @param start A \code{unsigned int} that indicates the starting row.
#' @param end A \code{unsigned int} that indicates the ending row.
#' @return x A \code{matrix} with matrix rows displayed in reversed order
#' @details Consider a vector x=[[1,2],[3,4]], the function would output x=[[3,4],[1,2]].
#' Start and end must be valid C++ matrix locations. (e.g. matrix rows start at 0 and not 1)
#' @author JJB
#' @examples
#' x = matrix(c(1,2,3,4), nrow=2,byrow=TRUE)
#' rev_row_subset(x, 1, 0)
rev_row_subset <- function(x, start, end) {
    .Call('r2arma_rev_row_subset', PACKAGE = 'r2arma', x, start, end)
}

#' @title Reverse Armadillo Vector
#' @description Reverses the order of an Armadillo Vector
#' @usage reverse_vec(x)
#' @param x A \code{column vector} of length N
#' @return x A \code{column vector} with its contents reversed.
#' @details Consider a vector x=[1,2,3,4,5], the function would output x=[5,4,3,2,1].
#' @author JJB
#' @examples
#' x = 1:5
#' reverse_vec(x)
reverse_vec <- function(x) {
    .Call('r2arma_reverse_vec', PACKAGE = 'r2arma', x)
}

#' @title Transform an Armadillo field<vec> to a matrix
#' @description Unlists vectors in a field and places them into a matrix
#' @param x A \code{field<vec>}.
#' @return A \code{mat} containing the field elements within a column.
#' @author JJB
field_to_matrix <- function(x) {
    .Call('r2arma_field_to_matrix', PACKAGE = 'r2arma', x)
}

#' @title Accumulation of Armadillo field<vec>
#' @description Sums vectors in a field into a single variable.
#' @param x A \code{field<vec>}.
#' @return An \code{mat} containing the field elements within a column.
#' @author JJB
sum_field_vec <- function(x) {
    .Call('r2arma_sum_field_vec', PACKAGE = 'r2arma', x)
}

#' @title Generate a sequence of values
#' @description Creates a vector containing a sequence of values starting at the initial point and going to the terminal point.
#' @param a An \code{int}, that denotes the starting point.
#' @param b An \code{int}, that denotes the ending point.
#' @return A \code{vector} containing values moving from a to b. There are no restrictions on A's range.
#' @seealso \code{\link{rwishart}} 
#' @author James J Balamuta
#' @examples 
#' # Call with the following data:
#' seq_int(3, 5)
#' seq_int(5, 3)
seq_int <- function(a, b) {
    .Call('r2arma_seq_int', PACKAGE = 'r2arma', a, b)
}

#' @title Lagged Differences in Armadillo
#' @description Returns the ith difference of a time series of rth lag.
#' @param x A \code{vec} that is the time series
#' @param lag A \code{unsigned int} that indicates the lag
#' @param differences A \code{dif} that indicates how many differences should be taken
#' @return A \code{vector} containing the differenced time series.
#' @author JJB
#' @examples
#' x = rnorm(10000, 0, 1)
#' diff_cpp(x,1,1)
diff_cpp <- function(x, lag, differences) {
    .Call('r2arma_diff_cpp', PACKAGE = 'r2arma', x, lag, differences)
}

#' @title Converting an ARMA Process to an Infinite MA Process
#' @description Takes an ARMA function and converts it to an infinite MA process.
#' @param ar A \code{column vector} of length p
#' @param ma A \code{column vector} of length q
#' @param lag_max A \code{int} of the largest MA(Inf) coefficient required.
#' @return A \code{column vector} containing coefficients
#' @details This function is a port of the base stats package's ARMAtoMA. There is no significant speed difference between the two.
#' @author R Core Team and JJB
#' @examples
#' # ARMA(2,1)
#' ARMAtoMA_cpp(c(1.0, -0.25), 1.0, 10)
#' # ARMA(0,1)
#' ARMAtoMA_cpp(numeric(0), 1.0, 10)
ARMAtoMA_cpp <- function(ar, ma, lag_max) {
    .Call('r2arma_ARMAtoMA_cpp', PACKAGE = 'r2arma', ar, ma, lag_max)
}

#' @title Time Series Convolution Filters
#' @description Applies a convolution filter to a univariate time series.
#' @param x A \code{column vector} of length T
#' @param filter A \code{column vector} of length f
#' @param sides An \code{int} that takes either 1:for using past values only or 2: filter coefficients are centered around lag 0.
#' @param circular A \code{bool} that indicates if the filter should be wrapped around the ends of the time series.
#' @return A \code{column vec} that contains the results of the filtering process.
#' @details This is a port of the cfilter function harnessed by the filter function in stats. 
#' It is about 5-7 times faster than R's base function. The benchmark was done on iMac Late 2013 using vecLib as the BLAS.
#' @author R Core Team and JJB
#' @examples
#' x = 1:100
#' # 
#' cfilter(x, rep(1, 3), sides = 2, circular = FALSE)
#' # Using R's function
#' filter(x, rep(1, 3))
#' #
#' cfilter(x, rep(1, 3), sides = 1, circular = FALSE)
#' # Using R's function
#' filter(x, rep(1, 3), sides = 1)
#' #
#' cfilter(x, rep(1, 3), sides = 1, circular = TRUE)
#' # Using R's function
#' filter(x, rep(1, 3), sides = 1, circular = TRUE)
cfilter <- function(x, filter, sides, circular) {
    .Call('r2arma_cfilter', PACKAGE = 'r2arma', x, filter, sides, circular)
}

#' @title Time Series Recursive Filters
#' @description Applies a recursive filter to a univariate time series.
#' @usage rfilter(x, filter, init)
#' @param x A \code{column vector} of length T
#' @param filter A \code{column vector} of length f
#' @param init A \code{column vector} of length f that contains the initial values of the time series in reverse.
#' @return x A \code{column vector} with its contents reversed.
#' @details Note: The length of 'init' must be equal to the length of 'filter'.
#' This is a port of the rfilter function harnessed by the filter function in stats. 
#' It is about 6-7 times faster than R's base function. The benchmark was done on iMac Late 2013 using vecLib as the BLAS.
#' @author R Core Team and JJB
#' @examples
#' x = 1:100
#' # 
#' rfilter(x, rep(1, 3), rep(1, 3))
#' # Using R's function
#' filter(x, rep(1, 3), method="recursive", init=rep(1, 3))
rfilter <- function(x, filter, init) {
    .Call('r2arma_rfilter', PACKAGE = 'r2arma', x, filter, init)
}

#' @title Compute Theoretical ACF for an ARMA Process
#' @description Compute the theoretical autocorrelation function for an ARMA process.
#' @usage ARMAacf_cpp(ar,ma,lag_max)
#' @param ar A \code{vector} of length p containing AR coefficients
#' @param ma A \code{vector} of length q containing MA coefficients
#' @param lag_max A \code{unsigned integer} indicating the maximum lag necessary
#' @return x A \code{matrix} listing values from 1...nx in one column and 1...1, 2...2,....,n...n, in the other
#' @details This is an implementaiton of the ARMAacf function in R. It is approximately 40x times faster. The benchmark was done on iMac Late 2013 using vecLib as the BLAS.
#' @author R Core Team and JJB
#' @examples
#' # ARMA(2,1)
#' ARMAacf_cpp(c(1.0, -0.25), 1.0, lag_max = 10)
#' # ARMA(0,1)
#' ARMAacf_cpp(numeric(0), .35, lag_max = 10)
ARMAacf_cpp <- function(ar, ma, lag_max) {
    .Call('r2arma_ARMAacf_cpp', PACKAGE = 'r2arma', ar, ma, lag_max)
}

#' @title Discrete Fourier Transformation for Autocovariance Function
#' @description Calculates the autovariance function (ACF) using Discrete Fourier Transformation.
#' @param x A \code{cx_vec}. 
#' @return A \code{vec} containing the ACF.
#' @details 
#' This implementation is 2x as slow as Rs. 
#' Two issues: 1. memory resize and 2. unoptimized fft algorithm in arma.
#' Consider piping back into R and rewrapping the object. (Decrease of about 10 microseconds.)
#' @examples
#' x=rnorm(100)
#' dft_acf(x)
dft_acf <- function(x) {
    .Call('r2arma_dft_acf', PACKAGE = 'r2arma', x)
}

